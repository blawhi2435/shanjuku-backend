package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"strconv"

	"github.com/blawhi2435/shanjuku-backend/domain"
	"github.com/blawhi2435/shanjuku-backend/graph"
	"github.com/blawhi2435/shanjuku-backend/graph/model"
	"github.com/blawhi2435/shanjuku-backend/internal/cerror"
	"github.com/blawhi2435/shanjuku-backend/internal/ctxtool"
	"github.com/blawhi2435/shanjuku-backend/internal/mapper/graphmodel"
)

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.CreateGroupInput) (*model.CreateGroupPayload, error) {
	var response *model.CreateGroupPayload

	ctx, err := ctxtool.SetTokenToContext(ctx)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	group, err := r.GroupUsecase.CreateGroup(ctx, &domain.Group{
		Name: input.Name,
	})
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	modelGroup := graphmodel.MappingGroupDomainToGraphqlModel(group)

	response = &model.CreateGroupPayload{
		Group: modelGroup,
	}

	return response, nil
}

// EditGroup is the resolver for the editGroup field.
func (r *mutationResolver) EditGroup(ctx context.Context, input model.EditGroupInput) (*model.EditGroupPayload, error) {
	var response *model.EditGroupPayload

	ctx, err := ctxtool.SetTokenToContext(ctx)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	groupID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}
	group, err := r.GroupUsecase.UpdateGroup(ctx, &domain.Group{
		ID:   groupID,
		Name: input.Name,
	})
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	modelGroup := graphmodel.MappingGroupDomainToGraphqlModel(group)

	response = &model.EditGroupPayload{
		Group: modelGroup,
	}

	return response, nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, input *model.DeleteGroupInput) (*model.DeleteGroupPayload, error) {
	var response *model.DeleteGroupPayload

	ctx, err := ctxtool.SetTokenToContext(ctx)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	groupID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	err = r.GroupUsecase.DeleteGroup(ctx, groupID)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	response = &model.DeleteGroupPayload{
		Success: true,
	}

	return response, nil
}

// InviteUser is the resolver for the inviteUser field.
func (r *mutationResolver) InviteUser(ctx context.Context, input model.InviteUserInput) (*model.InviteUserPayload, error) {
	var response *model.InviteUserPayload

	ctx, err := ctxtool.SetTokenToContext(ctx)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	groupID, err := strconv.ParseInt(input.GroupID, 10, 64)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	userIDs := make([]int64, 0)
	for _, v := range input.UserIds {
		id, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			return response, cerror.GetGQLError(ctx, err)
		}
		userIDs = append(userIDs, id)
	}

	users, err := r.GroupUsecase.InviteUser(ctx, groupID, userIDs)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	modelUsers := make([]*model.User, 0)
	for _, v := range users {
		modelUsers = append(modelUsers, graphmodel.MappingUserDomainToGraphqlModel(v))
	}

	response = &model.InviteUserPayload{
		Users: modelUsers,
	}

	return response, nil
}

// RemoveUser is the resolver for the removeUser field.
func (r *mutationResolver) RemoveUser(ctx context.Context, input model.RemoveUserInput) (*model.RemoveUserPayload, error) {
	var response *model.RemoveUserPayload

	ctx, err := ctxtool.SetTokenToContext(ctx)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	groupID, err := strconv.ParseInt(input.GroupID, 10, 64)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	userID, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	err = r.GroupUsecase.RemoveUser(ctx, groupID, userID)
	if err != nil {
		return response, cerror.GetGQLError(ctx, err)
	}

	response = &model.RemoveUserPayload{
		Success: true,
	}

	return response, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id string) (*model.Group, error) {
	groupID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, cerror.GetGQLError(ctx, err)
	}

	group, err := r.GroupUsecase.QueryByGroupID(ctx, groupID)
	if err != nil {
		return nil, cerror.GetGQLError(ctx, err)
	}

	modelGroup := graphmodel.MappingGroupDomainToGraphqlModel(group)

	return modelGroup, nil
}

// Users is the resolver for the users field.
func (r *groupResolver) Users(ctx context.Context, obj *model.Group) ([]*model.User, error) {
	groupID, err := strconv.ParseInt(obj.ID, 10, 64)
	if err != nil {
		return nil, cerror.GetGQLError(ctx, err)
	}

	users, err := r.GroupUsecase.QueryGroupUsers(ctx, groupID)
	if err != nil {
		return nil, cerror.GetGQLError(ctx, err)
	}

	modelUsers := make([]*model.User, 0)
	for _, v := range users {
		modelUsers = append(modelUsers, graphmodel.MappingUserDomainToGraphqlModel(v))
	}

	return modelUsers, nil
}

// Group returns graph.GroupResolver implementation.
func (r *Resolver) Group() graph.GroupResolver { return &groupResolver{r} }

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type groupResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
